const distances =  resistGraph.measuredDataPoints.distances;
const resistivities =  resistGraph.measuredDataPoints.resistivities;


// Evaluating RRMSE(Relative Root Mean Square Error)
const evalRRMSE = (observedYs, modelResponseVect) => {
  let errorSquareSum = 0;
  observedYs.forEach((observedY, index) => {
    errorSquareSum += Math.pow(Math.log10(observedY) - Math.log10(modelResponseVect[index]), 2);
  });
  const RMSE = Math.sqrt(errorSquareSum / observedYs.length);
  return (RMSE * 100);
}

/**
 * Adds random noise to each element of a numerical array.
 *
 * @param {number[]} dataArray The input array of numbers to which noise will be added.
 * @param {number} noisePercentage The maximum percentage of noise to apply to each data point. For 5%, use 5.
 * @returns {number[]} A new array containing the data with the added random noise.
 */
function addNoise(dataArray, noisePercentage) {
  if (!Array.isArray(dataArray)) {
    throw new Error("Invalid input: dataArray must be an array of numbers.");
  }
  const noiseFactor = noisePercentage / 100;
  const noisyArray = dataArray.map(value => {
    if (typeof value !== 'number') {
      console.warn("Warning: Non-numeric value found in array, skipping.", value);
      return value;
    }

    const randomMultiplier = (Math.random() - 0.5) * 2 + (Math.round(Math.random()) * Math.exp(noiseFactor));
    const noise = randomMultiplier * noiseFactor * value;

    return value + noise;
  });

  return noisyArray;
}

/* GENERAL SETTINGS */
//Toggle execution of inversion module.
const execInversion = true;
//For the same initial model, the WINRESIST RMSE calculation is greater than zero when this software's RMSE calculation yields 0.00. This could be due to slight differences in the forward module filters or rounding errors. To better benchmark results, this variable corrects for the difference by adding 0.1 to the error calculation generated by this software.
const emulate_WINRESIST_error = true;

//Parameters
const initialModel = [
  {resistivity:373,thickness: 0.5, depth: 0.5},
  {resistivity:141, thickness: 1.5, depth: 2},
  {resistivity:73,thickness: 4, depth: 6},
  {resistivity:60,thickness: 60, depth: 16},
  {resistivity:17.5, thickness: Infinity, depth: null}

];
const modelParamsNo = initialModel.length


//Field data transformation and analysis
const logResistivities = resistivities.map(resistivity => Math.log(resistivity));
const resistivitiesNo = resistivities.length;


//Function to calculate the resistivity transform for the uppermost layer
const evalTransform = (parameters, u, subjacentLayerTransform, layerNo) => {
  if (layerNo === 1) return subjacentLayerTransform
  else {
    //Using Pekeris recursive relation
    const layer = parameters[layerNo - 2];
    const angle = layer.thickness / u;

    const transformNumerator = subjacentLayerTransform + (layer.resistivity * Math.tanh(angle));
    const transformDenominator = 1 + ((subjacentLayerTransform * Math.tanh(angle)) / layer.resistivity);
    const layerTransform = transformNumerator / transformDenominator;


    return evalTransform(parameters, u, layerTransform, layerNo - 1);
  }

};

// Nyman-Landisman 13 point filter
const inverseFilterCoeffs = [105, -262, 416, -746, 1605, -4390, 13396, -27841, 16448, 8183, 2525, 336, 225];

const deconvolver = (distance, model) => {
  const samplingInterval = Math.log(10) / 4.438, f = 10;
  const e = Math.exp(0.5 * samplingInterval);
  const transformArray = [];
  let u = distance * Math.exp(-f * samplingInterval), convolutionSum = 0;

  for (let i = 0; i < 27; ++i) {
    const topmostTransform = evalTransform(model, u, model[model.length - 1].resistivity, model.length);
    transformArray.push(topmostTransform);
    u = u * e;
  };

  for (let i = 0; i < inverseFilterCoeffs.length; i++) {
    convolutionSum += inverseFilterCoeffs[i] * transformArray[2 * i]
  };

  return convolutionSum / 10000;
}


// FORWARD MODEL OPERATOR
const forwardModelOperator = (model) => {
  const modelRoaArr = distances.map(distance => deconvolver(distance, model));
  return modelRoaArr.map(rho => [Math.log(rho)]);
}



//LOG DOMAIN LEVENBERG-MARQUARDT INVERSION SCHEME 
//Iteration properties
const ITERATION_LIMIT = 200;
const maxError = 1e-5;
const paramUpperBound = Math.log(1e+5);


//Update metric properties: Emperical constants that influence the damping coefficient update. Altering any one of these can significantly affect model convergence...for better or worse. (:
const τ = 3;
const β = 1; //β = 1 seems to emulate WINRESIST inversion. β = 2 results in a more agressive inversion, possibly overfitting. 
const λ = 3;

//Regularization Intensity: Regularizes the parameter update step to prevent the algorithm from overfitting the data. You can think of this parameter as sort of a confidence measurement. The higher it is the lesser the algorithm would perturb the initial model provided by the analyst, suggesting that they are confident the initial model is close to the real thing. Setting this to zero tells the algorithm to explore the solution space as much as it can to converge to a plausible model that best fits the data.
// const μ = 0.15; // default
const μ = 0.15; 


let initialLogModel = initialModel.map(layer => ({
  logResistivity: Math.log(layer.resistivity),
  logThickness: Math.log(layer.thickness),
  depth: layer.depth
}));

let currentIterationModel = [...initialLogModel];
let iterationCount = 0;
let vFactor = 2;
let inversionProgress = 0;
let nextDampingCoefficient = null;



//Create parameter vector
const createParamVector = (model) => {
   const modelParamsVect = [];

  for (let i = 0; i < model.length; ++i) {
    modelParamsVect[i] = [model[i].logResistivity];
    if (i < model.length - 1) { // Last layer has no thickness parameter
      modelParamsVect[i + modelParamsNo] = [model[i].logThickness];
    }
  };

  return modelParamsVect
}

const initialModelVect = createParamVector(initialLogModel);
const logResistivitiesVect = logResistivities.map(resistivity => [resistivity]);

const logDomainForwardOperator = (logModel) => {
  const linearModel = logModel.map((layer, index, array) => {
    const prevLayer = array[index - 1];
    const thickness = Math.exp(layer.logThickness);
    return {
      resistivity: Math.exp(layer.logResistivity),
      thickness: thickness,
      depth: (thickness + prevLayer?.depth) || thickness
    };
  });

  return forwardModelOperator(linearModel);
};


//  Jacobian matrix construction 
const evalForwardDiffJacobian = (logModel, modelResponseVect) => {
    let j = 0;
    let N = 0;
    const Δ = 1e-6; 

  return (resistGraph.createMatrix([resistivitiesNo, (2 * modelParamsNo) - 1], (i) => {
    const δM = Array((2 * modelParamsNo) - 1).fill(0);
    δM[j] = Δ;

    let perturbation = 0;
    const perturbedLogModel = logModel.map((layer, index) => {
      const ΔlogResistivity = layer.logResistivity + ((δM[index] * (1 + layer.logResistivity)) || 0);
      const ΔlogThickness = layer.logThickness + ((δM[index + modelParamsNo] * (1 + layer.logThickness)) || 0);

      return {
        logResistivity: ΔlogResistivity,
        logThickness: ΔlogThickness,
      };
    });

    // console.log(perturbation)
    const perturbedResponse = logDomainForwardOperator(perturbedLogModel)[N][0];
    const originalResponse = modelResponseVect[N][0];
    const jacobianElem = (perturbedResponse - originalResponse) / Δ;

    ++j;
    if (j === ((2 * modelParamsNo) - 1)) {
      j = 0;
      ++N;
    }
    return jacobianElem;
  }));
};


let count = 0;
console.time('LM Scheme - Full Log Domain');
if(execInversion){
  while (iterationCount < ITERATION_LIMIT) {
    const previousModel = [...currentIterationModel];
  
    const previousModelResponseVect = logDomainForwardOperator(previousModel);
    const residualVect = resistGraph.differenceHandler(logResistivitiesVect, previousModelResponseVect);
    const χ = (resistGraph.productHandler(resistGraph.getTranspose(residualVect), residualVect))[0][0];
  
  
    const jacobian = evalForwardDiffJacobian(previousModel, previousModelResponseVect);
    const jacobianTranspose = resistGraph.getTranspose(jacobian);
  
    const hessian = resistGraph.productHandler(jacobianTranspose, jacobian);
    const previousModelVect = createParamVector(previousModel);
    const modelDifferenceVect = resistGraph.differenceHandler(previousModelVect, initialModelVect);
    const regularizationTerm = resistGraph.productHandler(μ, modelDifferenceVect);
    const gFactor = resistGraph.productHandler(jacobianTranspose, residualVect);
    const gFactor_regularized  = resistGraph.differenceHandler(gFactor, regularizationTerm);
    const iterationMaxError = resistGraph.getMaxElem(gFactor_regularized );
  
    let dampingCoefficient = 0;
  
    if (iterationCount === 0) {
      const hessianDiag = resistGraph.createDiagonalMatrix(hessian);
      dampingCoefficient = 1e-3 * resistGraph.getMaxElem(hessianDiag);
    } else {
      dampingCoefficient = nextDampingCoefficient;
    }
  
    if (!isFinite(dampingCoefficient)) break;
  
    const pertubationVectDenominator = resistGraph.getInverse(
      resistGraph.sumHandler(
        hessian,
        resistGraph.productHandler(
          dampingCoefficient,
          resistGraph.createIdentityMatrix((2 * modelParamsNo) - 1)[['_data']]
        )
      )
    );
  
    const pertubationVect = resistGraph.productHandler(pertubationVectDenominator, gFactor_regularized );
  
    currentIterationModel = currentIterationModel.map((layer, index) => {
      const logResistivityUpdate = layer.logResistivity + pertubationVect[index][0];
      let logThicknessUpdate = layer.logThickness;
  
      // The last layer has infinite thickness, so we don't update it.
      if (pertubationVect[index + modelParamsNo] !== undefined) {
        logThicknessUpdate = layer.logThickness + pertubationVect[index + modelParamsNo][0];
        logThicknessUpdate = Math.min(logThicknessUpdate,paramUpperBound);
  
      }
  
      return {
        logResistivity: Math.min(logResistivityUpdate,paramUpperBound),
        logThickness: logThicknessUpdate
      };
    });
  
    const currentModelVect = createParamVector(currentIterationModel);
    const currentModelResponseVect = logDomainForwardOperator(currentIterationModel);
    const currentModelResidualVect = resistGraph.differenceHandler(logResistivitiesVect, currentModelResponseVect);
    const Δχ = (resistGraph.productHandler(resistGraph.getTranspose(currentModelResidualVect), currentModelResidualVect))[0][0];
  
    const metricNumerator = χ - Δχ;
    const metricDenominator = resistGraph.productHandler(
      resistGraph.getTranspose(pertubationVect),
      resistGraph.sumHandler(
        resistGraph.productHandler(dampingCoefficient, pertubationVect),
        gFactor_regularized 
      )
    )[0][0];
  
    const metric = metricNumerator / metricDenominator;
  
    if (metric > 0) {
      vFactor = 2;
      const metricDampingCoefficient = (1 - Math.pow((β * (2 * metric) - 1), λ));
      let multiplier = 1;
      nextDampingCoefficient = dampingCoefficient * Math.max(1 / τ, metricDampingCoefficient);
   
    } else {
      currentIterationModel = previousModel;
      nextDampingCoefficient = dampingCoefficient * vFactor;
      vFactor *= 2;
    }
  
    const chiSquaredConvergence = χ / (resistivitiesNo - modelParamsNo);
    if (Math.abs(iterationMaxError) < maxError || chiSquaredConvergence < maxError) {
      console.log("suitable convergence reached!")
      console.log(`iterationMaxError:${iterationMaxError}`, `chiSquaredConvergence:${chiSquaredConvergence}`)
      break;
    }
  
    // Update progress
    const progress = inversionProgress + Math.round((iterationCount / ITERATION_LIMIT) * 100);
    if (progress < 100) {
      if (((progress % 10) === 0) && inversionProgress !== progress) {
        inversionProgress = progress;
        resistGraph.inversionProgressHandler(progress);
      }
    }
  
    ++iterationCount; ++count
  }

    ++iterationCount; ++count
}
console.log(count)

// Final model presented in linear domain.
let depth = 0;
const finalModel = currentIterationModel.map((layer) => {
  const thickness = Math.exp(layer.logThickness);
  depth += thickness;

  return {
    resistivity: Math.exp(layer.logResistivity),
    thickness: thickness,
    depth
  };
});

console.log("Final Inverted Model:", finalModel);
console.timeEnd('LM Scheme - Full Log Domain');
console.log("Final Inverted Model:", finalModel);
console.timeEnd('LM Scheme - Full Log Domain');

 resistGraph.inversionProgressHandler(100);

const inversionResistivities = forwardModelOperator(finalModel).map(logResistivity => Math.exp(logResistivity[0]));
const RRMSE = evalRRMSE(resistivities, inversionResistivities);
document.getElementById('RMSE').innerHTML = `RMSE: ${RRMSE.toFixed(3)}`;

console.log(inversionResistivities)


// Set the dimensions of the SVG container
const width = 800;
const height = 400;

const modelData = logInversionResistivities.map((response,index) => ({x:distances[index],y:Math.exp(response[0])}));
const measuredData = resistivities.map((resistivity,index) => ({x:distances[index],y:resistivity}));


D3.plot(width,height,measuredData,modelData);
gsapAnim.fromTo('circle',{y:'10px', opacity: 0}, {y:'0px', opacity: 1, duration:.5, stagger:.06, ease: 'power3.out'});



