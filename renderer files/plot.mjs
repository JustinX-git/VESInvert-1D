// const distances =  resistGraph.measuredDataPoints.distances;
// const resistivities =  resistGraph.measuredDataPoints.resistivities;


// Evaluating RRMSE(Relative Root Mean Square Error)
const evalRRMSE = (observedYs, modelResponseVect, emulate) => {
  let errorSquareSum = 0;
  observedYs.forEach((observedY, index) => {
    errorSquareSum += Math.pow(Math.log10(observedY) - Math.log10(modelResponseVect[index]), 2);
  });
  const RMSE = Math.sqrt(errorSquareSum / observedYs.length);
  return (RMSE * 100) + (emulate ? 0.1 : 0) ;
}

/**
 * Adds random noise to each element of a numerical array.
 *
 * @param {number[]} dataArray The input array of numbers to which noise will be added.
 * @param {number} noisePercentage The maximum percentage of noise to apply to each data point. For 5%, use 5.
 * @returns {number[]} A new array containing the data with the added random noise.
 */
function addNoise(dataArray, noisePercentage) {
  if (!Array.isArray(dataArray)) {
    throw new Error("Invalid input: dataArray must be an array of numbers.");
  }
  const noiseFactor = noisePercentage / 100;
  const noisyArray = dataArray.map(value => {
    if (typeof value !== 'number') {
      console.warn("Warning: Non-numeric value found in array, skipping.", value);
      return value;
    }

    const randomMultiplier = (Math.random() - 0.5) * 2 + (Math.round(Math.random()) * Math.exp(noiseFactor));
    const noise = randomMultiplier * noiseFactor * value;

    return value + noise;
  });

  return noisyArray;
}


/**
 * Evaluates the complexity of a VES inversion model based on a custom metric.
 *
 * The Model Complexity Index (MCI) is calculated as:
 * MCI = N * log(RCF_total) * (1 + SF_total)
 *
 * where:
 * - N: Number of layers.
 * - RCF_total: Sum of absolute resistivity ratios between adjacent layers.
 * - SF_total: Sum of suppression factors for intermediate layers.
 *
 * @param {Array<Object>} model An array of layer objects.
 * Each object must have 'resistivity' and 'thickness' properties.
 * @returns {Object} An object containing the final MCI and its components (N, RCF, SF).
 */
function evalModelComplexity(model) {
  // 1. Calculate N (Number of Layers)
  const N = model.length;

  if (N < 3) {
    // Cannot calculate RCF or SF for models with less than 3 layers,
    // as there are no intermediate layers or enough contrast pairs.
    return {
      mci: 0,
      nLayers: N,
      resistivityContrastFactor: 0,
      suppressionFactor: 0,
      message: "Model complexity cannot be calculated for less than 3 layers."
    };
  }

  // 2. Calculate Total Resistivity Contrast Factor (RCF)
  let rcfTotal = 0;
  for (let i = 0; i < N - 1; i++) {
    const ratio = model[i + 1].resistivity / model[i].resistivity;
    rcfTotal += ratio;
  }

  // 3. Calculate Total Suppression Factor (SF)
  let sfTotal = 0;
  // Iterate through intermediate layers (from the second to the second-to-last)
  for (let i = 1; i < N - 1; i++) {
    const rho_prev = model[i - 1].resistivity;
    const rho_curr = model[i].resistivity;
    const rho_next = model[i + 1].resistivity;
    const thickness_curr = model[i].thickness;

    // Check if the current layer's resistivity is intermediate
    const isIntermediate = (rho_prev < rho_curr && rho_curr < rho_next) ||
                           (rho_prev > rho_curr && rho_curr > rho_next);

    if (isIntermediate) {
      // Avoid division by zero if thickness is 0 or infinity
      if (thickness_curr > 0 && isFinite(thickness_curr)) {
        const logTerm = Math.abs(
          Math.log(rho_curr / rho_prev) + Math.log(rho_curr / rho_next)
        );
        // Avoid division by zero if the layer is perfectly geometrically mean
        if (logTerm > 0) {
            const sf_layer = 1 / (thickness_curr * logTerm);
            sfTotal += sf_layer;
        }
      }
    }
  }

  // 4. Calculate the final Model Complexity Index (MCI)
  // We use Math.max(1, rcfTotal) to avoid Math.log() of a value <= 0
  const mci = N * Math.log(Math.max(1, rcfTotal)) * (1 + sfTotal);

  return {
    modelComplexityIndex: mci,
    nLayers: N,
    resistivityContrastFactor: rcfTotal,
    suppressionFactor: sfTotal,
  };
}



/* GENERAL SETTINGS */
//Toggle execution of inversion module.
const execInversion = true;
//For the same initial model, the WINRESIST RMSE calculation is greater than zero when this software's RMSE calculation yields 0.00. This could be due to slight differences in the forward module filters or rounding errors. To better benchmark results, this variable corrects for the difference by adding 0.1 to the error calculation generated by this software.
const emulate_WINRESIST_error = false;

//Parameters
const initialModel = [
       {resistivity:939.58,thickness: 2.25, depth: 2.25},
   {resistivity:2162.94,thickness: 20, depth: 22.5},
   {resistivity:1468.98,thickness: 40, depth: 62.5},
   {resistivity:800,thickness: 50, depth: 112.5},
   {resistivity:1175.34,thickness: Infinity, depth: null}
];
const modelParamsNo = initialModel.length

 const distances = [1.00, 1.50, 2.00, 3.00, 4.00, 5.00, 7.00,12.00,17.00,27.00,37.00, 47.00,67.00,117.00, 167.00,217.00, 267.00];
 const resistivities = [505.7284, 699.9053, 902.0600,1279.47,1004.3590, 1521.4335, 2020.3217, 2252.1811, 2726.43472, 2863.3286, 2659.0984, 2249.5478,1065.814,360.5608,650.0000,950.0000,1175.3402];







//Field data transformation and analysis
const logDistances = distances.map(distance => Math.log(distance));
// const noisyResistivity = addNoise(resistivities,0);
// const fieldlogResistivities = resistivities.map(resistivity => Math.log(resistivity));
const logResistivities = resistivities.map(resistivity => Math.log(resistivity));
const resistivitiesNo = resistivities.length;

// const smoothenedResistivities = Array.from(resistGraph.applySmoothing(resistivities,distances,{windowSize: 11,derivative: 0,polynomial: 3}));
 


//Function to calculate the resistivity transform for the uppermost layer
const evalTransform = (parameters, u, subjacentLayerTransform, layerNo) => {
  if (layerNo === 1) return subjacentLayerTransform
  else {
    //Using Pekeris recursive relation
    const layer = parameters[layerNo - 2];
    const angle = layer.thickness / u;

    const transformNumerator = subjacentLayerTransform + (layer.resistivity * Math.tanh(angle));
    const transformDenominator = 1 + ((subjacentLayerTransform * Math.tanh(angle)) / layer.resistivity);
    const layerTransform = transformNumerator / transformDenominator;


    return evalTransform(parameters, u, layerTransform, layerNo - 1);
  }

};

// Nyman-Landisman 13 point filter
const inverseFilterCoeffs = [105, -262, 416, -746, 1605, -4390, 13396, -27841, 16448, 8183, 2525, 336, 225];

const deconvolver = (distance, model) => {
  const samplingInterval = Math.log(10) / 4.438, f = 10;
  const e = Math.exp(0.5 * samplingInterval);
  const transformArray = [];
  let u = distance * Math.exp(-f * samplingInterval), convolutionSum = 0;

  for (let i = 0; i < 27; ++i) {
    const topmostTransform = evalTransform(model, u, model[model.length - 1].resistivity, model.length);
    transformArray.push(topmostTransform);
    u = u * e;
  };

  for (let i = 0; i < inverseFilterCoeffs.length; i++) {
    convolutionSum += inverseFilterCoeffs[i] * transformArray[2 * i]
  };

  return convolutionSum / 10000;
}


// FORWARD MODEL OPERATOR
const forwardModelOperator = (model) => {
  const modelRoaArr = distances.map(distance => deconvolver(distance, model));
  return modelRoaArr.map(rho => [Math.log(rho)]);
}



//LOG DOMAIN LEVENBERG-MARQUARDT INVERSION SCHEME 
//Iteration properties
const ITERATION_LIMIT = 200;
const maxError = 1e-5;
const paramUpperBound = Math.log(1e+5);
const adaptiveRegularization = false;
const RMSELimit = 40;
const modelComplexityLimit = 30;
const maxDifficultyCoefficient = Math.round(((RMSELimit * modelComplexityLimit) + Math.pow(RMSELimit,3)) * 100)/ 100;


//Update metric properties: Hyperparameters that influence the damping coefficient update. Altering any one of these can significantly affect model convergence...for better or worse. (:
const τ = 3;
const β = 1; //β = 1 seems to emulate WINRESIST inversion. β = 2 results in a more agressive inversion, possibly overfitting. 
const λ = 3;

//Regularization Intensity: Hyperparameter that regularizes the parameter update step to prevent overfitting. You can think of this parameter as sort of a confidence measurement. The higher it is the lesser the algorithm would perturb the initial model provided by the analyst, suggesting that they are confident the initial model is close to the real thing. Setting this to zero tells the algorithm to explore the solution space as much as it can to converge to a plausible model that best fits the data.
// const μ = 0.15; // default
let μ = 0; 


let initialLogModel = initialModel.map(layer => ({
  logResistivity: Math.log(layer.resistivity),
  logThickness: Math.log(layer.thickness),
  depth: layer.depth
}));

let currentIterationModel = [...initialLogModel];
let iterationCount = 0;
let vFactor = 2;
let inversionProgress = 0;
let nextDampingCoefficient = null;



//Create parameter vector
const createParamVector = (model) => {
   const modelParamsVect = [];

  for (let i = 0; i < model.length; ++i) {
    modelParamsVect[i] = [model[i].logResistivity];
    if (i < model.length - 1) { // Last layer has no thickness parameter
      modelParamsVect[i + modelParamsNo] = [model[i].logThickness];
    }
  };

  return modelParamsVect
}

const initialModelVect = createParamVector(initialLogModel);
const logResistivitiesVect = logResistivities.map(resistivity => [resistivity]);

//In the case where the user desires an 'adaptive regularization' intensity. The value of the parameter is evaluated relative to how well the user's initial model fits the provided data (RMSE) and how difficult inverting the initial model may be using the Model Complexity Index (MCI).
if(!adaptiveRegularization){
  μ = 0.15
}else{
   const initialModelResistivities = forwardModelOperator(initialModel).map(logResistivity => Math.exp(logResistivity[0]));
   const error = Math.min(RMSELimit, evalRRMSE(resistivities, initialModelResistivities, emulate_WINRESIST_error));
   const modelComplexityIndex = Math.min(modelComplexityLimit, evalModelComplexity(initialModel).modelComplexityIndex);
   const difficultyCoefficient = Math.round(((error * modelComplexityIndex) + Math.pow(error,3)) * 100)/ 100;

   μ = 1 - (difficultyCoefficient/maxDifficultyCoefficient)
   console.log(`difficultyCoefficient:${difficultyCoefficient} maxDifficultyCoefficient:${maxDifficultyCoefficient}`);
   
  //  if(modelComplexityIndex <= complexityLimit){
  //     μ = parseFloat((1 - (modelComplexityIndex/complexityLimit)).toFixed(2))
  //  }
   
  }
  console.log(μ)



const logDomainForwardOperator = (logModel) => {
  const linearModel = logModel.map((layer, index, array) => {
    const prevLayer = array[index - 1];
    const thickness = Math.exp(layer.logThickness);
    return {
      resistivity: Math.exp(layer.logResistivity),
      thickness: thickness,
      depth: (thickness + prevLayer?.depth) || thickness
    };
  });

  return forwardModelOperator(linearModel);
};


//  Jacobian matrix construction 
const evalForwardDiffJacobian = (logModel, modelResponseVect) => {
  let j = 0;
  let N = 0;
  const Δ = 1e-6;

  return (resistGraph.createMatrix([resistivitiesNo, (2 * modelParamsNo) - 1], (i) => {
    const δM = Array((2 * modelParamsNo) - 1).fill(0);
    δM[j] = Δ;

    let perturbation = 0;
    const perturbedLogModel = logModel.map((layer, index) => {
      const ΔlogResistivity = layer.logResistivity + ((δM[index] * (1 + layer.logResistivity)) || 0);
      const ΔlogThickness = layer.logThickness + ((δM[index + modelParamsNo] * (1 + layer.logThickness)) || 0);

      return {
        logResistivity: ΔlogResistivity,
        logThickness: ΔlogThickness,
      };
    });

    // console.log(perturbation)
    const perturbedResponse = logDomainForwardOperator(perturbedLogModel)[N][0];
    const originalResponse = modelResponseVect[N][0];
    const jacobianElem = (perturbedResponse - originalResponse) / Δ;

    ++j;
    if (j === ((2 * modelParamsNo) - 1)) {
      j = 0;
      ++N;
    }
    return jacobianElem;
  }));
};


let count = 0;
console.time('LM Scheme - Full Log Domain');
if(execInversion){
  while (iterationCount < ITERATION_LIMIT) {
    const previousModel = [...currentIterationModel];
  
    const previousModelResponseVect = logDomainForwardOperator(previousModel);
    const residualVect = resistGraph.differenceHandler(logResistivitiesVect, previousModelResponseVect);
    const χ = (resistGraph.productHandler(resistGraph.getTranspose(residualVect), residualVect))[0][0];
  
  
    const jacobian = evalForwardDiffJacobian(previousModel, previousModelResponseVect);
    const jacobianTranspose = resistGraph.getTranspose(jacobian);
  
    const hessian = resistGraph.productHandler(jacobianTranspose, jacobian);
    const previousModelVect = createParamVector(previousModel);
    const modelDifferenceVect = resistGraph.differenceHandler(previousModelVect, initialModelVect);
    const regularizationTerm = resistGraph.productHandler(μ, modelDifferenceVect);
    const gFactor = resistGraph.productHandler(jacobianTranspose, residualVect);
    const gFactor_regularized  = resistGraph.differenceHandler(gFactor, regularizationTerm);
    const iterationMaxError = resistGraph.getMaxElem(gFactor_regularized );
  
    let dampingCoefficient = 0;
  
    if (iterationCount === 0) {
      const hessianDiag = resistGraph.createDiagonalMatrix(hessian);
      dampingCoefficient = 1e-3 * resistGraph.getMaxElem(hessianDiag);
    } else {
      dampingCoefficient = nextDampingCoefficient;
    }
  
    if (!isFinite(dampingCoefficient)) break;
  
    const pertubationVectDenominator = resistGraph.getInverse(
      resistGraph.sumHandler(
        hessian,
        resistGraph.productHandler(
          dampingCoefficient,
          resistGraph.createIdentityMatrix((2 * modelParamsNo) - 1)[['_data']]
        )
      )
    );
  
    const pertubationVect = resistGraph.productHandler(pertubationVectDenominator, gFactor_regularized );
  
    currentIterationModel = currentIterationModel.map((layer, index) => {
      const logResistivityUpdate = layer.logResistivity + pertubationVect[index][0];
      let logThicknessUpdate = layer.logThickness;
  
      // The last layer has infinite thickness, so we don't update it.
      if (pertubationVect[index + modelParamsNo] !== undefined) {
        logThicknessUpdate = layer.logThickness + pertubationVect[index + modelParamsNo][0];
        logThicknessUpdate = Math.min(logThicknessUpdate,paramUpperBound);
  
      }
  
      return {
        logResistivity: Math.min(logResistivityUpdate,paramUpperBound),
        logThickness: logThicknessUpdate
      };
    });
  
    const currentModelVect = createParamVector(currentIterationModel);
    const currentModelResponseVect = logDomainForwardOperator(currentIterationModel);
    const currentModelResidualVect = resistGraph.differenceHandler(logResistivitiesVect, currentModelResponseVect);
    const Δχ = (resistGraph.productHandler(resistGraph.getTranspose(currentModelResidualVect), currentModelResidualVect))[0][0];
  
    const metricNumerator = χ - Δχ;
    const metricDenominator = resistGraph.productHandler(
      resistGraph.getTranspose(pertubationVect),
      resistGraph.sumHandler(
        resistGraph.productHandler(dampingCoefficient, pertubationVect),
        gFactor_regularized 
      )
    )[0][0];
  
    const metric = metricNumerator / metricDenominator;
  
    if (metric > 0) {
      vFactor = 2;
      const metricDampingCoefficient = (1 - Math.pow((β * (2 * metric) - 1), λ));
      let multiplier = 1;
      nextDampingCoefficient = dampingCoefficient * Math.max(1 / τ, metricDampingCoefficient);
   
    } else {
      currentIterationModel = previousModel;
      nextDampingCoefficient = dampingCoefficient * vFactor;
      vFactor *= 2;
    }
  
    const chiSquaredConvergence = χ / (resistivitiesNo - modelParamsNo);
    if (Math.abs(iterationMaxError) < maxError || chiSquaredConvergence < maxError) {
      console.log("suitable convergence reached!")
      console.log(`iterationMaxError:${iterationMaxError}`, `chiSquaredConvergence:${chiSquaredConvergence}`)
      break;
    }
  
    // Update progress
    const progress = inversionProgress + Math.round((iterationCount / ITERATION_LIMIT) * 100);
    if (progress < 100) {
      if (((progress % 10) === 0) && inversionProgress !== progress) {
        inversionProgress = progress;
        resistGraph.inversionProgressHandler(progress);
      }
    }
  
    ++iterationCount; ++count
  }
}
console.log(count);

// Final model presented in linear domain.
let depth = 0;
const finalModel = currentIterationModel.map((layer) => {
  const thickness = Math.exp(layer.logThickness);
  depth += thickness;

  return {
    resistivity: Math.exp(layer.logResistivity),
    thickness: thickness,
    depth
  };
});

console.log("Final Inverted Model:", finalModel);
console.timeEnd('LM Scheme - Full Log Domain');

resistGraph.inversionProgressHandler(100);

const inversionResistivities = forwardModelOperator(finalModel).map(logResistivity => Math.exp(logResistivity[0]));
const RRMSE = evalRRMSE(resistivities, inversionResistivities, emulate_WINRESIST_error);
document.getElementById('RMSE').innerHTML = `RMSE: ${RRMSE.toFixed(3)}`;

console.log(inversionResistivities)


// Set the dimensions of the SVG container
const width = 800;
const height = 400;

const modelData = inversionResistivities.map((response, index) => ({ x: distances[index], y: response }));
const measuredData = resistivities.map((resistivity, index) => ({ x: distances[index], y: resistivity }));
const smoothenedData = logResistivities.map((resistivity, index) => ({ x: distances[index], y: Math.exp(resistivity) }));


D3.plot(width, height, measuredData, smoothenedData, modelData);
gsapAnim.fromTo('circle', { y: '10px', opacity: 0 }, { y: '0px', opacity: 1, duration: .5, stagger: .06, ease: 'power3.out' });



